/**
 * Beancount v3 Pad Directive - Formal Specification
 *
 * This Alloy model formalizes the pad directive semantics,
 * which automatically generates balancing transactions.
 */

module pad

open util/ordering[Date]

-- =============================================================================
-- SIGNATURES (Data Types)
-- =============================================================================

sig Date {}

sig Account {}

sig Currency {}

sig Decimal {
    value: one Int
}

/**
 * A Balance represents an account's balance at a point in time.
 */
sig Balance {
    account: one Account,
    currency: one Currency,
    amount: one Decimal,
    asOfDate: one Date
}

/**
 * A Pad directive specifies automatic balance reconciliation.
 */
sig Pad {
    padDate: one Date,
    targetAccount: one Account,
    sourceAccount: one Account,
    -- The balance assertion this pad is linked to
    linkedBalance: lone BalanceAssertion,
    -- The generated padding transaction (if any)
    generatedTxn: lone PaddingTransaction,
    -- Status
    isUsed: one Int,      -- 1 if pad generated a transaction
    hasError: one Int     -- 1 if there's an error
}

/**
 * A BalanceAssertion checks that an account has a specific balance.
 */
sig BalanceAssertion {
    assertDate: one Date,
    account: one Account,
    currency: one Currency,
    expectedAmount: one Decimal,
    -- The actual balance at assertion time
    actualAmount: one Decimal,
    -- Whether the assertion passed
    passed: one Int  -- 1 if passed, 0 if failed
}

/**
 * A PaddingTransaction is generated by a pad to reconcile balances.
 */
sig PaddingTransaction {
    txnDate: one Date,
    targetAccount: one Account,
    sourceAccount: one Account,
    currency: one Currency,
    amount: one Decimal  -- Amount added to target (negative means subtraction)
}

-- =============================================================================
-- HELPER PREDICATES
-- =============================================================================

/**
 * Check if date d1 is strictly before date d2.
 */
pred dateBefore[d1, d2: Date] {
    d1 in d2.prevs
}

/**
 * Check if date d1 is before or equal to date d2.
 */
pred dateLeq[d1, d2: Date] {
    d1 in d2.prevs or d1 = d2
}

/**
 * A balance assertion matches a pad if:
 * - Same account
 * - Balance date is after pad date
 */
pred balanceMatchesPad[b: BalanceAssertion, p: Pad] {
    b.account = p.targetAccount
    dateBefore[p.padDate, b.assertDate]
}

/**
 * Compute if padding is needed (balance differs from expected).
 */
pred paddingNeeded[b: BalanceAssertion] {
    b.actualAmount.value != b.expectedAmount.value
}

/**
 * Compute the padding amount needed.
 */
fun paddingAmount[b: BalanceAssertion]: Int {
    sub[b.expectedAmount.value, b.actualAmount.value]
}

-- =============================================================================
-- PAD SEMANTICS
-- =============================================================================

/**
 * A pad is valid if it has a subsequent balance assertion for the same account.
 */
pred padHasBalance[p: Pad] {
    some b: BalanceAssertion | balanceMatchesPad[b, p]
}

/**
 * A pad is unused if no padding was generated (error condition).
 */
pred padIsUnused[p: Pad] {
    -- Has a linked balance but no difference needed
    some p.linkedBalance
    not paddingNeeded[p.linkedBalance]
}

/**
 * Apply pad semantics - link to balance and generate transaction if needed.
 */
pred applyPad[p: Pad] {
    -- Must have a subsequent balance assertion
    padHasBalance[p] implies {
        -- Link to the first matching balance assertion
        some b: BalanceAssertion | {
            balanceMatchesPad[b, p]
            p.linkedBalance = b

            -- If padding needed, generate transaction
            paddingNeeded[b] implies {
                some t: PaddingTransaction | {
                    p.generatedTxn = t
                    t.txnDate = p.padDate
                    t.targetAccount = p.targetAccount
                    t.sourceAccount = p.sourceAccount
                    t.currency = b.currency
                    t.amount.value = paddingAmount[b]
                    p.isUsed = 1
                    p.hasError = 0
                }
            }

            -- If no padding needed, pad is unused (error)
            not paddingNeeded[b] implies {
                no p.generatedTxn
                p.isUsed = 0
                p.hasError = 1
            }
        }
    }

    -- No matching balance assertion is an error
    not padHasBalance[p] implies {
        no p.linkedBalance
        no p.generatedTxn
        p.isUsed = 0
        p.hasError = 1
    }
}

-- =============================================================================
-- CONSTRAINTS
-- =============================================================================

/**
 * Constraint: Only one pad per account before each balance assertion.
 */
pred onePadPerBalance {
    all b: BalanceAssertion |
        lone p: Pad | balanceMatchesPad[b, p]
}

/**
 * Constraint: Pad date must be before linked balance date.
 */
fact padBeforeBalance {
    all p: Pad |
        some p.linkedBalance implies dateBefore[p.padDate, p.linkedBalance.assertDate]
}

/**
 * Constraint: Generated transaction matches pad accounts.
 */
fact generatedTxnMatchesPad {
    all p: Pad |
        some p.generatedTxn implies {
            p.generatedTxn.targetAccount = p.targetAccount
            p.generatedTxn.sourceAccount = p.sourceAccount
            p.generatedTxn.txnDate = p.padDate
        }
}

/**
 * Constraint: Generated transaction currency matches balance currency.
 */
fact generatedTxnMatchesCurrency {
    all p: Pad |
        (some p.generatedTxn and some p.linkedBalance) implies
            p.generatedTxn.currency = p.linkedBalance.currency
}

-- =============================================================================
-- INVARIANTS
-- =============================================================================

/**
 * Invariant: A pad without a balance assertion is always an error.
 */
pred padWithoutBalanceIsError {
    all p: Pad |
        not padHasBalance[p] implies p.hasError = 1
}

/**
 * Invariant: A used pad has a generated transaction.
 */
pred usedPadHasTransaction {
    all p: Pad |
        p.isUsed = 1 implies some p.generatedTxn
}

/**
 * Invariant: An unused pad has no generated transaction.
 */
pred unusedPadNoTransaction {
    all p: Pad |
        p.isUsed = 0 implies no p.generatedTxn
}

/**
 * Invariant: Generated transaction reconciles the balance.
 * After applying the padding, the balance should match expected.
 */
pred paddingReconcilesBalance {
    all p: Pad |
        (some p.generatedTxn and some p.linkedBalance) implies {
            let b = p.linkedBalance, t = p.generatedTxn |
                add[b.actualAmount.value, t.amount.value] = b.expectedAmount.value
        }
}

-- =============================================================================
-- ASSERTIONS (Properties to Check)
-- =============================================================================

/**
 * A pad without a subsequent balance always fails.
 */
assert padRequiresBalance {
    all p: Pad |
        (applyPad[p] and not padHasBalance[p])
        implies p.hasError = 1
}

/**
 * A pad that generates a transaction is marked as used.
 */
assert generatedTxnMeansUsed {
    all p: Pad |
        (applyPad[p] and some p.generatedTxn)
        implies p.isUsed = 1
}

/**
 * The padding amount equals the difference between expected and actual.
 */
assert paddingAmountCorrect {
    all p: Pad |
        (some p.generatedTxn and some p.linkedBalance) implies
            p.generatedTxn.amount.value = paddingAmount[p.linkedBalance]
}

/**
 * A pad with matching balance (no difference) is unused.
 */
assert matchingBalanceUnused {
    all p: Pad, b: BalanceAssertion |
        (applyPad[p] and
         balanceMatchesPad[b, p] and
         p.linkedBalance = b and
         b.actualAmount.value = b.expectedAmount.value)
        implies p.isUsed = 0
}

-- =============================================================================
-- EXAMPLE SCENARIOS
-- =============================================================================

/**
 * Example: Pad generates transaction when balance differs.
 */
pred examplePadGeneratesTransaction {
    some p: Pad, b: BalanceAssertion, t: PaddingTransaction |
        -- Balance assertion expects 1000 but actual is 0
        b.actualAmount.value = 0
        b.expectedAmount.value = 1000

        -- Pad is before balance
        dateBefore[p.padDate, b.assertDate]
        p.targetAccount = b.account

        -- Apply pad
        applyPad[p]

        -- Should generate transaction with amount 1000
        p.linkedBalance = b
        p.generatedTxn = t
        t.amount.value = 1000
        p.isUsed = 1
        p.hasError = 0
}

/**
 * Example: Pad is unused when balance already matches.
 */
pred examplePadUnusedWhenMatches {
    some p: Pad, b: BalanceAssertion |
        -- Balance assertion matches actual
        b.actualAmount.value = 1000
        b.expectedAmount.value = 1000

        -- Pad is before balance
        dateBefore[p.padDate, b.assertDate]
        p.targetAccount = b.account

        -- Apply pad
        applyPad[p]

        -- Should be unused error
        p.isUsed = 0
        p.hasError = 1
        no p.generatedTxn
}

/**
 * Example: Pad without balance is error.
 */
pred examplePadWithoutBalance {
    some p: Pad |
        -- No balance assertion for this account after pad date
        no b: BalanceAssertion | balanceMatchesPad[b, p]

        -- Apply pad
        applyPad[p]

        -- Should be error
        p.hasError = 1
        no p.generatedTxn
}

-- =============================================================================
-- RUN COMMANDS
-- =============================================================================

run examplePadGeneratesTransaction for 4 but 1 Pad, 1 BalanceAssertion, 1 PaddingTransaction
run examplePadUnusedWhenMatches for 4 but 1 Pad, 1 BalanceAssertion
run examplePadWithoutBalance for 4 but 1 Pad, 0 BalanceAssertion

check padRequiresBalance for 5
check generatedTxnMeansUsed for 5
check paddingAmountCorrect for 5
check matchingBalanceUnused for 5
